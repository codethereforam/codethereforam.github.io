<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[node.js和JavaScript的关系]]></title>
    <url>%2F2018-01-11-node-js%2F</url>
    <content type="text"><![CDATA[node.js是一个基于 Chrome V8 引擎的 JavaScript 运行时环境。 一、类比JavaScript和java JavaScript java V8 JVM node.js JRE JavaScript和java都是一门编程语言，至于两者的关系，是雷锋和雷峰塔的关系 V8是google开源的JavaScript引擎，用于执行JavaScript，类似JVM执行java字节码。在node.js诞生之前，V8是内置于Chromium中的，现在也内置于node.js中 node.js=V8+内置基本模块（大多用JavaScript编写），类似JRE=JVM+java标准库 node.js诞生之前，JavaScript只能运行于浏览器，现在也可以在服务器端运行于node.js 二、翻译一段Quora回答下面翻译一段Quora上What is the difference between JavaScript and Node.js问题下Mattias Petter Johansson的回答。 JavaScript是一门语言 node.js不是一门语言，也不是一种特殊的JavaScript方言 - 它仅仅就是用于运行普通JavaScript代码的东西 所有浏览器都有运行网页上JavaScript的JavaScript引擎。Firefox有叫做Spidermonkey的引擎，Safari有JavaScriptCore，Chrome有V8 node.js就是带有能操作I/O和网络库的V8引擎，因此你能够在浏览器之外使用JavaScript创建shell脚本和后台服务或者运行在硬件上 三、浏览器端和服务器端JavaScript组成区别浏览器端： ECMAScript，描述了JavaScript语言的语法和基本对象 文档对象模型（DOM），描述处理网页内容的方法和接口 浏览器对象模型（BOM），描述与浏览器进行交互的方法和接口 服务器端： ECMAScript node.js内置模块：文件系统I/O、网络（HTTP、TCP、UDP、DNS、TLS/SSL等）、二进制数据流、加密算法、数据流等等 四、参考资料 https://zh.wikipedia.org/zh-hans/Node.js https://zh.wikipedia.org/zh-hans/JavaScript]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>node.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[完善chrome翻译插件ChaZD，支持有道智云api]]></title>
    <url>%2F2017-12-31-ChaZD-youdao%2F</url>
    <content type="text"><![CDATA[首先放上该项目的github地址：https://github.com/codethereforam/ChaZD 之前想找一个chrome支持划词翻译的插件，最终在知乎上看到了这个回答，推荐的是ChaZD，用了一段时间我就喜欢上它的简洁方便。 这个插件用的是有道翻译旧的api，由于有道限制每个api key每小时只能调用1000次，有时候会翻译不了，而且旧的api于 2017-12-31 后停止运行。 于是，我就改写了这个插件，使其可以调用有道智云新的api。我fork的是lytofb/ChaZD，作者在原来ChaZD代码的基础上加了自定义api key的功能。 一、新增功能改用有道智云新的api，可以自定义应用ID和密钥 二、使用说明2.1 下载插件下载地址：ChaZD-thinkam 如果你的浏览器支持使用非Web Store的插件，直接将下载的crx拖到chrome://extensions/页面。 如果不支持，将crx文件扩展名改为zip并解压，在chrome://extensions/勾选开发者模式，接着在 Chrome 设置拓展的地方，点击加载未打包的拓展。详细步骤见chrome怎么安装非官方市场的插件？ - 小赖的回答。 2.2 申请有道智云翻译服务 注册有道智云帐号并登录到控制台页面 创建一个翻译实例：控制台 &gt; 自然语言翻译 &gt; 翻译实例 &gt; 创建翻译实例 创建一个应用并绑定翻译服务：控制台 &gt; 应用管理 &gt; 我的应用 &gt; 创建应用 &gt; 绑定服务 在插件中绑定应用——将上步骤的应用ID和应用密钥填写到插件设置页中相应的位置，如下图 2.3 具体翻译说明参考原作者github项目的README.md–https://github.com/ververcpp/ChaZD 三、结尾有道翻译旧的api于明天就停止运行了，原来的这个插件应该就不能用了，我赶在前一天完善了一下这个插件，之前的老用户可以继续使用。如果你没用过，欢迎尝试。 由于时间仓促加上我刚接触插件才两天，代码应该还有一些问题，欢迎提出问题。后面我会继续完善代码，添加一些定制功能。]]></content>
      <categories>
        <category>chrome插件</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>chrome插件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面向对象编程 —— java实现函数求导]]></title>
    <url>%2F2017-12-02-java-deriv%2F</url>
    <content type="text"><![CDATA[首先声明一点，本文主要介绍的是面向对象（OO）的思想，顺便谈下函数式编程，而不是教你如何准确地、科学地用java求出函数在一点的导数。 一、引子123456789101112def d(f) : def calc(x) : dx = 0.000001 # 表示无穷小的Δx return (f(x+dx) - f(x)) / dx # 计算斜率。注意，此处引用了外层作用域的变量 f return calc # 此处用函数作为返回值（也就是函数 f 的导数）# 计算二次函数 f(x) = x2 + x + 1的导数f = lambda x : x**2 + x + 1 # 先把二次函数用代码表达出来f1 = d(f)# 这个f1 就是 f 的一阶导数啦。注意，导数依然是个函数# 计算x=3的斜率f1(3)# 二阶导数f2 = d(f1) 首先，直接上一段python代码，请大家先分析下上面代码是用什么方法求导的。请不要被这段代码吓到，你无需纠结它的语法，只要明白它的求导思路。 以上代码引用自《为啥俺推荐 Python[4]：作为函数式编程语言的 Python》，这篇博客是促使我写篇文章的主要原因。 博主说“如果不用 FP，改用 OOP，上述需求该如何实现？俺觉得吧，用 OOP 来求导，这代码写起来多半是又丑又臭。” 我将信将疑，于是就用面向对象的java试了试，最后也没多少代码。如果用java8或以后版本，代码更少。 请大家思考一个问题，如何用面向对象的思路改写这个程序。请先好好思考，尝试编个程序再继续往下看。 考虑到看到这个标题进来的同学大多是学过java的，下面我用java，用面向对象的思路一步步分析这个问题。 二、求导文章开头我已近声明过了，本文不是来讨论数学的，求导只是我用来说明面向对象的一个例子。 如果你已经忘了开头那段代码的求导思路，请回头再看看，看看用python是如何求导的。 相信你只要听说过求导，肯定一眼就看出开头那段代码是用导数定义求导的。 代码中只是将无穷小Δx粗略地算做一个较小的值0.000001。 三、最初的想法1234567//自定义函数public class Function &#123; //函数：f(x) = 3x^3 + 2x^2 + x + 1 public double f(double x) &#123; return 3 * x * x * x + 2 * x * x + x + 1; &#125;&#125; 1234567891011121314151617181920//一元函数导函数public class DerivedFunction &#123; //表示无穷小的Δx private static final double DELTA_X = 0.000001; //待求导的函数 private Function function; public DerivedFunction(Function function) &#123; this.function = function; &#125; /** * 获取function在点x处的导数 * @param x 待求导的点 * @return 导数 */ public double get(double x) &#123; return (function.f(x + DELTA_X) - function.f(x)) / DELTA_X; &#125;&#125; 12345678public class Main &#123; public static void main(String[] args) &#123; //一阶导函数 DerivedFunction derivative = new DerivedFunction(new Function()); //打印函数在x=2处的一阶导数 System.out.println(derivative.get(2)); &#125;&#125; 先声明一点，考虑到博客篇幅，我使用了不规范的代码注释，希望大家不要被我误导。 我想只要大家好好思考了，应该至少会想到这步吧。代码我就不解释了，我只是用java改写了文章开头的那段python代码，做了一个简单的翻译工作。再请大家考虑下以上代码的问题。 刚开始，我思考这个问题想到的是建一个名为Function的类，类中有一个名为f的方法。但考虑到要每次要求新的函数导数时就得更改这个f方法的实现，明显不利于扩展，这违背了开闭原则。 估计有的同学没听过这个词，我就解释下：”对象（类，模块，函数等）应对扩展开放，但对修改封闭“。 于是我就没继续写下去，但为了让大家直观的感受到这个想法，我写这篇博客时就实现了一下这个想法。 请大家思考一下如何重构代码以解决扩展性问题。 四、初步的想法估计学过面向对象的同学会想到把Function类改成接口或抽象类，以后每次添加新的函数时只要重写这个接口或抽象类中的f方法，这就是面向接口编程，符合依赖反转原则，下面的代码就是这么做的。 再声明一点，考虑到篇幅的问题，后面的代码我会省去与之前代码重复的注释，有不明白的地方还请看看上一个想法中的代码。 1234//一元函数public interface Function &#123; double f(double x);&#125; 1234567//自定义的函数public class MyFunction implements Function &#123; @Override public double f(double x) &#123; return 3 * x * x * x + 2 * x * x + x + 1; &#125;&#125; 123456789101112public class DerivedFunction &#123; private static final double DELTA_X = 0.000001; private Function function; public DerivedFunction(Function function) &#123; this.function = function; &#125; public double get(double x) &#123; return (function.f(x + DELTA_X) - function.f(x)) / DELTA_X; &#125;&#125; 1234567public class Main &#123; public static void main(String[] args) &#123; //一阶导函数：f'(x) = 9x^2 + 4x + 1 DerivedFunction derivative = new DerivedFunction(new MyFunction()); System.out.println(derivative.get(2)); &#125;&#125; 我想认真看的同学可能会发现一个问题，我的翻译做的还不到位，开头那段python代码还可以轻松地求出二阶导函数（导数的导数），而我的代码却不行。 其实只要稍微修改以上代码的一个地方就可以轻松实现求二阶导，请再思考片刻。 五、后来的想法当我写出上面的代码时，我感觉完全可以否定“用 OOP 来求导，这代码写起来多半是又丑又臭”的观点。但还不能求二阶导，我有点不甘心。 于是我就动笔，列了一下用定义求一阶导和求二阶导的式子，想了想两个式子的区别与联系，突然想到导函数也是函数。 DerivedFunction的get方法和Function的f方法的参数和返回值一样，DerivedFunction可以实现Function接口，于是产生了下面的代码。 123public interface Function &#123; double f(double x);&#125; 12345678910111213public class DerivedFunction implements Function &#123; private static final double DELTA_X = 0.000001; private Function function; public DerivedFunction(Function function) &#123; this.function = function; &#125; @Override public double f(double x) &#123; return (function.f(x + DELTA_X) - function.f(x)) / DELTA_X; &#125;&#125; 123456789101112131415public class Main &#123; public static void main(String[] args) &#123; Function f1 = new DerivedFunction(new Function() &#123; @Override public double f(double x) &#123; return 3 * x * x * x + 2 * x * x + x + 1; &#125; &#125;); System.out.println(f1.f(2)); //二阶导函数：f''(x) = 18x + 4 Function f2 = new DerivedFunction(f1); //打印函数f(x) = 3x^3 + 2x^2 + x + 1在x=2处的二阶导数 System.out.println(f2.f(2)); &#125;&#125; 考虑到有的同学没学过java8或以上版本，以上代码没有用到java8函数式编程的新特性。 如果你接触过java8，请考虑如何改写以上代码，使其更简洁。 六、最后的想法12345678910111213public class DerivedFunction implements Function&lt;Double, Double&gt; &#123; private static final double DELTA_X = 0.000001; private Function&lt;Double, Double&gt; function; public DerivedFunction(Function&lt;Double, Double&gt; function) &#123; this.function = function; &#125; @Override public Double apply(Double x) &#123; return (function.apply(x + DELTA_X) - function.apply(x)) / DELTA_X; &#125;&#125; 123456public class Main &#123; public static void main(String[] args) &#123; //打印函数在x=2处的二阶导 System.out.println(new DerivedFunction(new DerivedFunction(x -&gt; 3 * x * x * x + 2 * x * x + x + 1)).apply(2.0)); &#125;&#125; 之前几个想法为了扩展Function接口，使用了外部类、匿名类的方式，其实也可以用内部类。而这在这里，我用了lambda表达式，是不是更简洁了。 这里用的Function接口用的是jdk自带的，我们不需要自己定义了。因为这是一个函数式接口，我们可以用lambda方便地实现。后来发现，其实这里用UnaryOperator这个接口更恰当。 现在大家有没有发现，用java、用OOP也可以非常简洁地实现求导，并不比开头的那段python代码麻烦很多。 七、编程范式在我看来，编程范式简单来说就是编程的一种模式，一种风格。 我先介绍其中的三个，你差不多就知道它的含义了。 7.1 面向对象程序设计（OOP）看到这里的同学应该对面向对象有了更直观的认识。在面向对象编程中，万物皆对象，抽象出类的概念。基本特性是封装、继承、多态，认识不深的同学可以再去我之前的代码中找找这三个特性。 我之前还介绍了面向对象的几个原则：开闭原则、依赖反转原则。其他还有单一职责原则、里氏替换原则、接口隔离原则。这是面向对象的5个基本原则，合称SOLID。 7.2 函数编程语言（FP）本文开头那段代码用的就是python函数式编程的语法，后来我又用java8函数式编程的语法翻译了这段代码。 相信你已经直观地感受到它的简洁，以函数为核心，几行代码就解决了求导的问题。 7.3 过程式编程（Procedural programming）大概学过编程都学过C，C语言就是一种过程式编程语言。在我看来，过程式编程大概就是为了完成一个需求，像记流水帐一样，平铺直叙下去。 八、结尾由于本人初学java，目前只能想到这么多。如果大家有更好的想法或者觉的我上面说的有问题，欢迎评论，望各位不吝赐教。 这是我的第一篇技术博客，但愿我说清楚了面向对象。如果对你有帮助，请点个赞或者评论下，给我点继续创作的动力。]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我的第一篇博客 —— 博客内容简介]]></title>
    <url>%2F2017-12-01-blog-intro%2F</url>
    <content type="text"><![CDATA[Software is like sex; it’s better when it’s free. —— Linus Torvalds (Linux之父) 在我看来，软件行业最吸引我的是其开源的精神，分享的精神。在这个相互分享的社区中，大家积极分享知识，相互促进，共同进步。 从我开始接触编程到现在，我基本没有在知识获取上花过钱。我基本是利用的互联网资源，小部分是学校图书馆的资源。 我学编程有一两年了，虽然没什么天赋，但我对编程感兴趣，也花了这一两年的大部分时间。 以前都是在利用互联网上别人分享的知识，如今，我也想分享一些我在学习过程中的一些思考与心得。 现在的想法是分享以下知识： 关于编程语言（java为主） 关于web开发]]></content>
      <categories>
        <category>博客通告</category>
      </categories>
      <tags>
        <tag>博客通告</tag>
      </tags>
  </entry>
</search>
