<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[nodejs+express+mysql实现restful风格的增删改查示例]]></title>
    <url>%2F2018-01-16-express-mysql%2F</url>
    <content type="text"><![CDATA[首先，放上项目github地址：https://github.com/codethereforam/express-mysql-demo 一、前言之前学的java，一直用的ssm框架写后台。前段时间接触到node.js，于是花了两天时间学了一下node.js并写了一个CRUD简单示例。由于前几天一直学用github pages搭建博客，一直没时间写README，今天有空补了上来。 下面来内容自于项目的README。 二、项目介绍基于node.js + express + mysql实现的restful风格的CRUD简单示例 2.1 组织结构12345678910111213141516171819202122├── app.js -- 应用配置├── bin│ └── www -- 项目运行脚本├── conf │ └── mysqlConf.js -- mysql配置文件├── dao│ ├── userDAO.js -- 封装和数据库的交互│ └── userSqlMap.js -- SQL语句封装├── model│ └── result.js -- 返回结果对象封装├── package.json -- 依赖模块├── project-datamodel│ └── user.sql -- 数据库脚本├── public -- 前端静态页面│ ├── add.html│ ├── css│ │ └── style.css│ ├── detail.html│ ├── index.html│ └── modify.html└── routes └── users.js -- 用户操作路由及业务逻辑 2.2 模块依赖1www -&gt; app.js -&gt; users.js -&gt; userDAO.js -&gt; mysqlConf.js &amp; userSqlMap.js 2.3 技术选型 后端技术 node.js express 前端技术 angular.js 三、环境搭建 node.js: https://nodejs.org/en/download/package-manager/ mysql: https://dev.mysql.com/doc/refman/5.7/en/installing.html 四、项目运行 下载代码并部署 12git clone https://github.com/codethereforam/express-mysql-demo.gitcd express-mysql-demo &amp;&amp; npm install #安装部署依赖的包 新建express-mysql-demo数据库，导入project-datamodel文件夹下的user.sql 修改conf/mysqlConf.js中数据库配置信息 启动 12# 切换到项目根路径npm start 打开首页: http://localhost:8888 五、开发过程及代码分析关于restful，可参考阮一峰的两篇文章： 理解RESTful架构 RESTful API 设计指南 我使用的IDE是IDEA，安装”NodeJS”插件后依次点击 1File -&gt; New Project -&gt; Node.js and NPM -&gt; Node.js Express App IDEA默认使用express-generator生成项目结构。 新建数据库”express-mysql-demo”: 1create database `express-mysql-demo`; 新建user表: 123456CREATE TABLE `express-mysql-demo`.`user` ( `id` INT UNSIGNED NOT NULL AUTO_INCREMENT, `username` VARCHAR(45) NOT NULL, `password` VARCHAR(45) NOT NULL, PRIMARY KEY (`id`))DEFAULT CHARACTER SET = utf8mb4; 表结构： 1234567+----------+------------------+------+-----+---------+----------------+| Field | Type | Null | Key | Default | Extra |+----------+------------------+------+-----+---------+----------------+| id | int(10) unsigned | NO | PRI | NULL | auto_increment || username | varchar(45) | NO | | NULL | || password | varchar(45) | NO | | NULL | |+----------+------------------+------+-----+---------+----------------+ mysql配置文件conf/mysqlConf.js: 12345678910module.exports = &#123; mysql: &#123; host: 'localhost', user: 'root', password: '', database:'express-mysql-demo', // 最大连接数，默认为10 connectionLimit: 10 &#125;&#125;; SQL语句封装模块dao/userSqlMap.js: 1234567var userSqlMap = &#123; add: 'insert into user(username, password) values(?, ?)', deleteById: 'delete from user where id = ?', update: 'update user set username=?, password=? where id=?', list: 'select * from user', getById: 'select * from user where id = ?'&#125;; 封装返回结果对象model/result.js: 123456exports.createResult = function(success, data) &#123; var result = &#123;&#125;; result.success = success; result.data = data; return result;&#125;; 我这里使用了工厂方法创建结果对象，对象有两个属性，success代表用户操作成功或失败，data存放后台要返回的数据。 下面分析修改用户部分信息的相关代码，全部的增删改查代码请将项目clone下来查看。 封装和数据库的交互模块dao/userDAO.js: 123456789101112131415var pool = mysql.createPool(mysqlConf.mysql);module.exports = &#123; getById: function (id, callback) &#123; pool.query(userSqlMap.getById, id, function (error, result) &#123; if (error) throw error; console.log(result[0]); callback(result[0]); &#125;); &#125;,update: function (user, callback) &#123; pool.query(userSqlMap.update, [user.username, user.password, user.id], function (error, result) &#123; if (error) throw error; callback(result.affectedRows &gt; 0); &#125;); &#125;&#125;; 这里使用了连接池，重复使用数据库连接，而不必每执行一次CRUD操作就获取、释放一次数据库连接，从而提高了对数据库操作的性能。 用户操作路由及实现业务逻辑routes/users.js: 12345678910111213141516171819/* patch users */router.patch('/:id', function (req, res) &#123; console.log('patch users called'); userDAO.getById(req.params.id, function (user) &#123; var username = req.body.username; if(username) &#123; user.username = username; &#125; var password = req.body.password; if(password) &#123; user.password = password; &#125; console.log(user); userDAO.update(user, function (success) &#123; var r = result.createResult(success, null); res.json(r); &#125;); &#125;);&#125;); router根据不同的HTTP请求方法和访问路径执行相应的回调函数，回调函数中先记录日志，然后检查用户传过来的数据，接着调用userDAO的相应CRUD方法，最后返回一个JSON对象给前端。这里修改用户部分信息对应HTTP方法是PATCH，而修改全部信息对应的是PUT。 应用配置app.js中配置用户操作相关的路由: 1app.use('/users', users); 前端public/index.html中与后台交互的JS代码： 12345678910111213141516(function (window) &#123; window.angular.module('list', []) .controller('listCtrl', function ($scope, $http) &#123; $scope.doPatch = function (id) &#123; var data = JSON.stringify(&#123; password: document.getElementById("pwd" + id).value &#125;); $http.patch("/users/" + id, data) .then(function (response) &#123; console.debug(response.data.success); &#125;, function (err) &#123; alert(err); &#125;); &#125;; &#125;); &#125;)(window); 前端使用angualr.js，ajax异步调用后端restful API，然后解析后台返回的JSON对象在界面上展示。]]></content>
      <categories>
        <category>web后台</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>node.js</tag>
        <tag>express</tag>
        <tag>restful</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使百度统计排除自己]]></title>
    <url>%2F2018-01-16-baidu-exclude%2F</url>
    <content type="text"><![CDATA[这两天开始使用github pages搭建博客，我添加了百度统计的功能。由于添加功能和美化界面，一天要打开很多次我的博客。我在百度统计后台看到博客浏览量有几百，而查看详细信息发现IP只有一个，就是我自己的。 于是我想能不能使百度统计排除自己，由于网上没搜到直接的解决办法，我想把我的解决办法分享给大家。 静态IP解决办法: 在百度统计管理后台添加需要排除的IP地址 贴上百度官方的教程: 通过设置过滤排除IP或域名 这个办法明显只对固定的IP有效，如果你的公网IP是固定的，你就不需要继续往下看了。我想看本文的大多和我一样是写博客的，自己的公网IP应该是动态的吧。有一种情况，你用了全局代理，VPS的公网IP是不变的，如果你是此类，只要把VPS的公网IP添加到排除规则就可以了。 动态IP由于IP是变化的，应该不好用上述黑名单的方法。我的解决办法使用广告过滤插件，我用的是uBlock Origin，uBlock默认是屏蔽百度统计的。如果你用的其他广告过滤插件没有默认屏蔽百度统计，你可以手动添加过滤规则，具体步骤自己google。 贴上百度统计被屏蔽的证据： 查看uBlock的dashboard: 3rd-party filters -&gt; Privacy -&gt; EasyPrivacy，可找到对应的屏蔽规则： 1||hm.baidu.com^$third-party 由此可联想到，你网站的PV和UV应该是大于你使用的统计工具得到的结果，有的用户用了过滤插件或油猴脚本就统计不到了。如果你的博客有点名气，可能还有用户用RSS订阅，这部分也统计不到。]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>博客搭建</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[node.js和JavaScript的关系]]></title>
    <url>%2F2018-01-11-node-js%2F</url>
    <content type="text"><![CDATA[node.js是一个基于 Chrome V8 引擎的 JavaScript 运行时环境。 一、类比JavaScript和java JavaScript java V8 JVM node.js JRE JavaScript和java都是一门编程语言，至于两者的关系，是雷锋和雷峰塔的关系 V8是google开源的JavaScript引擎，用于执行JavaScript，类似JVM执行java字节码。在node.js诞生之前，V8是内置于Chromium中的，现在也内置于node.js中 node.js=V8+内置基本模块（大多用JavaScript编写），类似JRE=JVM+java标准库 node.js诞生之前，JavaScript只能运行于浏览器，现在也可以在服务器端运行于node.js 二、翻译一段Quora回答下面翻译一段Quora上What is the difference between JavaScript and Node.js问题下Mattias Petter Johansson的回答。 JavaScript是一门语言 node.js不是一门语言，也不是一种特殊的JavaScript方言 - 它仅仅就是用于运行普通JavaScript代码的东西 所有浏览器都有运行网页上JavaScript的JavaScript引擎。Firefox有叫做Spidermonkey的引擎，Safari有JavaScriptCore，Chrome有V8 node.js就是带有能操作I/O和网络库的V8引擎，因此你能够在浏览器之外使用JavaScript创建shell脚本和后台服务或者运行在硬件上 三、浏览器端和服务器端JavaScript组成区别浏览器端： ECMAScript，描述了JavaScript语言的语法和基本对象 文档对象模型（DOM），描述处理网页内容的方法和接口 浏览器对象模型（BOM），描述与浏览器进行交互的方法和接口 服务器端： ECMAScript node.js内置模块：文件系统I/O、网络（HTTP、TCP、UDP、DNS、TLS/SSL等）、二进制数据流、加密算法、数据流等等 四、参考资料 https://zh.wikipedia.org/zh-hans/Node.js https://zh.wikipedia.org/zh-hans/JavaScript]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>node.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[完善chrome翻译插件ChaZD，支持有道智云api]]></title>
    <url>%2F2017-12-31-ChaZD-youdao%2F</url>
    <content type="text"><![CDATA[首先放上该项目的github地址: https://github.com/codethereforam/ChaZD 之前想找一个chrome支持划词翻译的插件，最终在知乎上看到了这个回答，推荐的是ChaZD，用了一段时间我就喜欢上它的简洁方便。 这个插件用的是有道翻译旧的api，由于有道限制每个api key每小时只能调用1000次，有时候会翻译不了，而且旧的api于 2017-12-31 后停止运行。 于是，我就改写了这个插件，使其可以调用有道智云新的api。我fork的是lytofb/ChaZD，作者在原来ChaZD代码的基础上加了自定义api key的功能。 如果大家在使用过程中遇到问题或者发现bug，欢迎在项目issues提出，也欢迎大家star、fork。 一、版本介绍如果你想体验原版的ChaZD，请选择v1.0.0，后面几个版本是我根据个人的使用情况和偏好添加了几个功能，欢迎尝试。 v1.0.0 改用有道智云api 可以自定义应用ID和密钥 v1.1.0 支持中译英 v1.2.0 划词翻译模式添加网络释义 v1.2.1 修复网络释义字体异常 修复无法翻译句子 popup翻译模式响应事件改为enter 二、使用说明2.1 下载插件下载地址：https://github.com/codethereforam/ChaZD/releases 选择你想要的版本，下载ChaZD-thinkam.crx文件。如果你的浏览器支持使用非Web Store的插件，直接将下载的crx拖到chrome://extensions/页面。 如果不支持，将crx文件扩展名改为zip并解压，在chrome://extensions/勾选开发者模式，接着在 Chrome 设置拓展的地方，点击加载未打包的拓展。详细步骤见chrome怎么安装非官方市场的插件？ - 小赖的回答。 2.2 申请有道智云翻译服务 注册有道智云帐号并登录到控制台页面 创建一个翻译实例：控制台 &gt; 自然语言翻译 &gt; 翻译实例 &gt; 创建翻译实例 创建一个应用并绑定翻译服务：控制台 &gt; 应用管理 &gt; 我的应用 &gt; 创建应用 &gt; 绑定服务 在插件中绑定应用——将上步骤的应用ID和应用密钥填写到插件设置页中相应的位置，如下图 2.3 具体翻译说明参考项目README: https://github.com/codethereforam/ChaZD/blob/master/README.md 三、结尾有道翻译旧的api于明天就停止运行了，原来的这个插件应该就不能用了，我赶在前一天完善了一下这个插件，之前的老用户可以继续使用。如果你没用过，欢迎尝试。 由于时间仓促加上我刚接触插件才两天，代码应该还有一些问题，欢迎提出问题。后面我会继续完善代码，添加一些定制功能。]]></content>
      <categories>
        <category>chrome插件</category>
      </categories>
      <tags>
        <tag>chrome插件</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面向对象编程 —— java实现函数求导]]></title>
    <url>%2F2017-12-02-java-deriv%2F</url>
    <content type="text"><![CDATA[首先声明一点，本文主要介绍的是面向对象（OO）的思想，顺便谈下函数式编程，而不是教你如何准确地、科学地用java求出函数在一点的导数。 一、引子123456789101112def d(f) : def calc(x) : dx = 0.000001 # 表示无穷小的Δx return (f(x+dx) - f(x)) / dx # 计算斜率。注意，此处引用了外层作用域的变量 f return calc # 此处用函数作为返回值（也就是函数 f 的导数）# 计算二次函数 f(x) = x2 + x + 1的导数f = lambda x : x**2 + x + 1 # 先把二次函数用代码表达出来f1 = d(f)# 这个f1 就是 f 的一阶导数啦。注意，导数依然是个函数# 计算x=3的斜率f1(3)# 二阶导数f2 = d(f1) 首先，直接上一段python代码，请大家先分析下上面代码是用什么方法求导的。请不要被这段代码吓到，你无需纠结它的语法，只要明白它的求导思路。 以上代码引用自《为啥俺推荐 Python[4]：作为函数式编程语言的 Python》，这篇博客是促使我写篇文章的主要原因。 博主说“如果不用 FP，改用 OOP，上述需求该如何实现？俺觉得吧，用 OOP 来求导，这代码写起来多半是又丑又臭。” 我将信将疑，于是就用面向对象的java试了试，最后也没多少代码。如果用java8或以后版本，代码更少。 请大家思考一个问题，如何用面向对象的思路改写这个程序。请先好好思考，尝试编个程序再继续往下看。 考虑到看到这个标题进来的同学大多是学过java的，下面我用java，用面向对象的思路一步步分析这个问题。 二、求导文章开头我已近声明过了，本文不是来讨论数学的，求导只是我用来说明面向对象的一个例子。 如果你已经忘了开头那段代码的求导思路，请回头再看看，看看用python是如何求导的。 相信你只要听说过求导，肯定一眼就看出开头那段代码是用导数定义求导的。 代码中只是将无穷小Δx粗略地算做一个较小的值0.000001。 三、最初的想法1234567//自定义函数public class Function &#123; //函数：f(x) = 3x^3 + 2x^2 + x + 1 public double f(double x) &#123; return 3 * x * x * x + 2 * x * x + x + 1; &#125;&#125; 1234567891011121314151617181920//一元函数导函数public class DerivedFunction &#123; //表示无穷小的Δx private static final double DELTA_X = 0.000001; //待求导的函数 private Function function; public DerivedFunction(Function function) &#123; this.function = function; &#125; /** * 获取function在点x处的导数 * @param x 待求导的点 * @return 导数 */ public double get(double x) &#123; return (function.f(x + DELTA_X) - function.f(x)) / DELTA_X; &#125;&#125; 12345678public class Main &#123; public static void main(String[] args) &#123; //一阶导函数 DerivedFunction derivative = new DerivedFunction(new Function()); //打印函数在x=2处的一阶导数 System.out.println(derivative.get(2)); &#125;&#125; 先声明一点，考虑到博客篇幅，我使用了不规范的代码注释，希望大家不要被我误导。 我想只要大家好好思考了，应该至少会想到这步吧。代码我就不解释了，我只是用java改写了文章开头的那段python代码，做了一个简单的翻译工作。再请大家考虑下以上代码的问题。 刚开始，我思考这个问题想到的是建一个名为Function的类，类中有一个名为f的方法。但考虑到要每次要求新的函数导数时就得更改这个f方法的实现，明显不利于扩展，这违背了开闭原则。 估计有的同学没听过这个词，我就解释下：”对象（类，模块，函数等）应对扩展开放，但对修改封闭“。 于是我就没继续写下去，但为了让大家直观的感受到这个想法，我写这篇博客时就实现了一下这个想法。 请大家思考一下如何重构代码以解决扩展性问题。 四、初步的想法估计学过面向对象的同学会想到把Function类改成接口或抽象类，以后每次添加新的函数时只要重写这个接口或抽象类中的f方法，这就是面向接口编程，符合依赖反转原则，下面的代码就是这么做的。 再声明一点，考虑到篇幅的问题，后面的代码我会省去与之前代码重复的注释，有不明白的地方还请看看上一个想法中的代码。 1234//一元函数public interface Function &#123; double f(double x);&#125; 1234567//自定义的函数public class MyFunction implements Function &#123; @Override public double f(double x) &#123; return 3 * x * x * x + 2 * x * x + x + 1; &#125;&#125; 123456789101112public class DerivedFunction &#123; private static final double DELTA_X = 0.000001; private Function function; public DerivedFunction(Function function) &#123; this.function = function; &#125; public double get(double x) &#123; return (function.f(x + DELTA_X) - function.f(x)) / DELTA_X; &#125;&#125; 1234567public class Main &#123; public static void main(String[] args) &#123; //一阶导函数：f'(x) = 9x^2 + 4x + 1 DerivedFunction derivative = new DerivedFunction(new MyFunction()); System.out.println(derivative.get(2)); &#125;&#125; 我想认真看的同学可能会发现一个问题，我的翻译做的还不到位，开头那段python代码还可以轻松地求出二阶导函数（导数的导数），而我的代码却不行。 其实只要稍微修改以上代码的一个地方就可以轻松实现求二阶导，请再思考片刻。 五、后来的想法当我写出上面的代码时，我感觉完全可以否定“用 OOP 来求导，这代码写起来多半是又丑又臭”的观点。但还不能求二阶导，我有点不甘心。 于是我就动笔，列了一下用定义求一阶导和求二阶导的式子，想了想两个式子的区别与联系，突然想到导函数也是函数。 DerivedFunction的get方法和Function的f方法的参数和返回值一样，DerivedFunction可以实现Function接口，于是产生了下面的代码。 123public interface Function &#123; double f(double x);&#125; 12345678910111213public class DerivedFunction implements Function &#123; private static final double DELTA_X = 0.000001; private Function function; public DerivedFunction(Function function) &#123; this.function = function; &#125; @Override public double f(double x) &#123; return (function.f(x + DELTA_X) - function.f(x)) / DELTA_X; &#125;&#125; 123456789101112131415public class Main &#123; public static void main(String[] args) &#123; Function f1 = new DerivedFunction(new Function() &#123; @Override public double f(double x) &#123; return 3 * x * x * x + 2 * x * x + x + 1; &#125; &#125;); System.out.println(f1.f(2)); //二阶导函数：f''(x) = 18x + 4 Function f2 = new DerivedFunction(f1); //打印函数f(x) = 3x^3 + 2x^2 + x + 1在x=2处的二阶导数 System.out.println(f2.f(2)); &#125;&#125; 考虑到有的同学没学过java8或以上版本，以上代码没有用到java8函数式编程的新特性。 如果你接触过java8，请考虑如何改写以上代码，使其更简洁。 六、最后的想法12345678910111213public class DerivedFunction implements Function&lt;Double, Double&gt; &#123; private static final double DELTA_X = 0.000001; private Function&lt;Double, Double&gt; function; public DerivedFunction(Function&lt;Double, Double&gt; function) &#123; this.function = function; &#125; @Override public Double apply(Double x) &#123; return (function.apply(x + DELTA_X) - function.apply(x)) / DELTA_X; &#125;&#125; 123456public class Main &#123; public static void main(String[] args) &#123; //打印函数在x=2处的二阶导 System.out.println(new DerivedFunction(new DerivedFunction(x -&gt; 3 * x * x * x + 2 * x * x + x + 1)).apply(2.0)); &#125;&#125; 之前几个想法为了扩展Function接口，使用了外部类、匿名类的方式，其实也可以用内部类。而这在这里，我用了lambda表达式，是不是更简洁了。 这里用的Function接口用的是jdk自带的，我们不需要自己定义了。因为这是一个函数式接口，我们可以用lambda方便地实现。后来发现，其实这里用UnaryOperator这个接口更恰当。 现在大家有没有发现，用java、用OOP也可以非常简洁地实现求导，并不比开头的那段python代码麻烦很多。 七、编程范式在我看来，编程范式简单来说就是编程的一种模式，一种风格。 我先介绍其中的三个，你差不多就知道它的含义了。 7.1 面向对象程序设计（OOP）看到这里的同学应该对面向对象有了更直观的认识。在面向对象编程中，万物皆对象，抽象出类的概念。基本特性是封装、继承、多态，认识不深的同学可以再去我之前的代码中找找这三个特性。 我之前还介绍了面向对象的几个原则：开闭原则、依赖反转原则。其他还有单一职责原则、里氏替换原则、接口隔离原则。这是面向对象的5个基本原则，合称SOLID。 7.2 函数编程语言（FP）本文开头那段代码用的就是python函数式编程的语法，后来我又用java8函数式编程的语法翻译了这段代码。 相信你已经直观地感受到它的简洁，以函数为核心，几行代码就解决了求导的问题。 7.3 过程式编程（Procedural programming）大概学过编程都学过C，C语言就是一种过程式编程语言。在我看来，过程式编程大概就是为了完成一个需求，像记流水帐一样，平铺直叙下去。 八、结尾由于本人初学java，目前只能想到这么多。如果大家有更好的想法或者觉的我上面说的有问题，欢迎评论，望各位不吝赐教。 这是我的第一篇技术博客，但愿我说清楚了面向对象。如果对你有帮助，请点个赞或者评论下，给我点继续创作的动力。]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我的第一篇博客 —— 博客内容简介]]></title>
    <url>%2F2017-12-01-blog-intro%2F</url>
    <content type="text"><![CDATA[Software is like sex; it’s better when it’s free. —— Linus Torvalds (Linux之父) 在我看来，软件行业最吸引我的是其开源的精神，分享的精神。在这个相互分享的社区中，大家积极分享知识，相互促进，共同进步。 从我开始接触编程到现在，我基本没有在知识获取上花过钱。我基本是利用的互联网资源，小部分是学校图书馆的资源。 我学编程有一两年了，虽然没什么天赋，但我对编程感兴趣，也花了这一两年的大部分时间。 以前都是在利用互联网上别人分享的知识，如今，我也想分享一些我在学习过程中的一些思考与心得。 现在的想法是分享以下知识： 关于编程语言（java为主） 关于web开发]]></content>
      <categories>
        <category>博客通告</category>
      </categories>
      <tags>
        <tag>博客通告</tag>
      </tags>
  </entry>
</search>
